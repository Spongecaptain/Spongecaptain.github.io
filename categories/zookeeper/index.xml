<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZooKeeper on Spongecaptain 的个人技术博客</title>
    <link>https://spongecaptain.cool/categories/zookeeper/</link>
    <description>Recent content in ZooKeeper on Spongecaptain 的个人技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Spongecaptain</copyright>
    <lastBuildDate>Thu, 10 Sep 2020 20:07:03 +0800</lastBuildDate>
    
	<atom:link href="https://spongecaptain.cool/categories/zookeeper/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ZooKeeper Watch 机制源码解析</title>
      <link>https://spongecaptain.cool/post/zookeeper/zookeeperwatch/</link>
      <pubDate>Thu, 10 Sep 2020 20:07:03 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/zookeeper/zookeeperwatch/</guid>
      <description>1. ZooKeeper Watch 概述 ZooKeeper Watch 机制类似于 Java 设计模式中的观察者模式或者监听模式，唯一的不同是不再基于线程间通信，而是基于进程间通信。 ZooKeeper Watch 机制是指，客户端在所有</description>
    </item>
    
    <item>
      <title>ZooKeeper 服务端线程分析</title>
      <link>https://spongecaptain.cool/post/zookeeper/zookeeperserverthreadmodel/</link>
      <pubDate>Sun, 06 Sep 2020 22:25:56 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/zookeeper/zookeeperserverthreadmodel/</guid>
      <description>我对 ZooKeeper release-3.6.1 的源码分析地址为：https://github.com/Spongecaptain/zookeeper Enjoy the Source Code. :) 1. 为什么从线程分析入</description>
    </item>
    
    <item>
      <title>ZooKeeper 的个人理解与总结</title>
      <link>https://spongecaptain.cool/post/zookeeper/myunderstandingofzookeeper/</link>
      <pubDate>Tue, 25 Aug 2020 19:56:06 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/zookeeper/myunderstandingofzookeeper/</guid>
      <description>1. ZAB 协议的核心是什么？ 其次，如果不考虑 Zookeeper 基于分布式共识算法的实现细节，我们可以将 Zookeeper 理解为文件系统 + 监听通知机制。 Zookeeper = 文件系统 + 监听通知机制 Zookeeper</description>
    </item>
    
  </channel>
</rss>